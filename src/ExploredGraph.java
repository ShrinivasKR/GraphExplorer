import java.util.*;
import java.util.function.Function;

/**
 * @Shrinivas Kopparam Ramanath, shrini, 1167430
 * Extra Credit Options Implemented, if any: Option A5E1
 *
 * Solution to Assignment 5 in CSE 373, Autumn 2014
 * University of Washington.
 * This assignment requires Java 8 JDK
 *
 * There are totally 15 TODOs, please read the instructions carefully
 * and don't change the signature of the methods
 *
 * Starter code provided by Steve Tanimoto and Si J. Liu, Nov. 21, 2014.
 *
 * This program solves the Towers of Hanoi puzzle using either breadth first search
 * or depth first search.
 *
 */

public class ExploredGraph {
    public final int NUMBER_OF_PEGS = 3; // number of pegs in this game
    private Set<Vertex> Ve; // collection of explored vertices
    private Set<Edge> Ee; // collection of explored edges
    private int VeSize; // size of collection of explored vertices
    private int EeSize; // size of collection of explored edges
    private List<Operator> operators; // collection of operators (6 in this game)
    private HashMap<Vertex, LinkedList<Edge>> map; // map of successor vertex with its edges

    public ExploredGraph() {
        initialize();
    }

    /**
     * Resets structures needed for use in Towers of Hanoi
     */
    public void initialize() {
        Ve = new LinkedHashSet<Vertex>();
        Ee = new LinkedHashSet<Edge>();
        map = new HashMap<Vertex, LinkedList<Edge>>();
        VeSize = 0;
        EeSize = 0;
        setOperators();
    }

    /**
     * Creates Operators that will simulate the movement of disks across pegs
     * based on the number of pegs
     */
    private void setOperators() {
        // (i, j) = {(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)}
        operators = new ArrayList<Operator>();
        for (int beginPeg = 0; beginPeg < NUMBER_OF_PEGS; beginPeg++) {
            for (int endPeg = 0; endPeg < NUMBER_OF_PEGS; endPeg++) {
                if (endPeg != beginPeg) {
                    operators.add(new Operator(beginPeg, endPeg));
                }
            }
        }
    }

    /**
     * To find the number of explored vertices
     * @return VeSize number of explored edges
     */
    public int nvertices() {
        return VeSize;
    }

    /**
     * To find the number of explored edges
     * @return EeSize number of explored edges
     */
    public int nedges() {
        return EeSize;
    }

    /**
     * Searches for ways to get the end disk configuration using depth first search
     * @param vi beginning configuration vertex
     * @param vj ending configuration vertex
     */
    public void dfs(Vertex vi, Vertex vj) {
        initialize();
        addNewVertex(vi);
        map.put(vi, new LinkedList<Edge>());
        dfsHelperMethod(vi, vj);
    }

    /**
     * Helper method to perform depth first search
     * @param currentVertex the current configuration of the disks
     * @param vj end target configuration vertex
     * @return status of whether the end configuration has been used
     */
    private boolean dfsHelperMethod(Vertex currentVertex, Vertex vj) {
        if (currentVertex != vj) {
            boolean foundSolution = false;

            // Goes through all possible movements till the solution is found or if other operators still remain
            for (int currentOperatorIndex = 0; currentOperatorIndex < operators.size() && !foundSolution; currentOperatorIndex++) {
                Operator currentOperator = operators.get(currentOperatorIndex);
                // Performs the movement if possible
                if (currentOperator.getPrecondition().apply(currentVertex)) {
                    Vertex newVertex = currentOperator.getTransition().apply(currentVertex);
                    if (!Ve.contains(newVertex)) {
                        addNewVertex(newVertex);
                        addNewEdge(currentVertex, newVertex);
                        // Performs the operation on new vertices generated by the operation on the current vertex
                        foundSolution = dfsHelperMethod(newVertex, vj);
                    }
                }
            }
            // if the solution is found returns true, else false
            return foundSolution;
        } else {
            return true;
        }
    }

    /**
     * Searches for ways to get the end disk configuration using breadth first search
     * @param vi initial configuration
     * @param vj end configuration
     */
    public void bfs(Vertex vi, Vertex vj) {
        initialize();
        Queue<Vertex> verticesToExplore = new LinkedList<Vertex>();
        addNewVertex(vi);
        verticesToExplore.add(vi);
        map.put(vi, new LinkedList<Edge>());
        boolean foundSolution = false;
        while (!verticesToExplore.isEmpty() && !foundSolution) {
            Vertex currentVertex = verticesToExplore.remove();
            for (int currentOperatorIndex = 0; currentOperatorIndex < operators.size() && !foundSolution; currentOperatorIndex++) { // goes through possible moves for the configuration
                Operator currentOperator = operators.get(currentOperatorIndex);
                if (currentOperator.getPrecondition().apply(currentVertex)) { // checks validity of move
                    Vertex newVertex = currentOperator.getTransition().apply(currentVertex);
                    if (!Ve.contains(newVertex)) { // marks unexplored configuration as explored
                        addNewVertex(newVertex);
                        addNewEdge(currentVertex, newVertex);
                        if (newVertex.equals(vj)) { // stops exploring if destination configuration is reached
                            foundSolution = true;
                        } else {
                            verticesToExplore.add(newVertex); // adds vertex to queue of search
                        }
                    }
                }
            }
        }
    }

    /**
     * Marks the vertex as explored
     * @param currentVertex
     */
    private void addNewVertex(Vertex currentVertex) {
        Ve.add(currentVertex);
        VeSize++;
    }

    /**
     * Creates an edge connecting the current configuration to another configuration
     * @param currentVertex the current configuration
     * @param newVertex another configuration
     */
    private void addNewEdge(Vertex currentVertex, Vertex newVertex) {
        Edge newEdge = new Edge(currentVertex, newVertex);
        Ee.add(newEdge);
        EeSize++;
        LinkedList<Edge> newVertexPath = (LinkedList<Edge>)map.get(currentVertex).clone();
        newVertexPath.add(newEdge);
        map.put(newVertex, newVertexPath);
    }

    /**
     * Retrieves the path taken to arrive at configuration vj
     * @param vj configuration
     * @return
     */
    public ArrayList<Vertex> retrievePath(Vertex vj) {
        ArrayList<Vertex> path = new ArrayList<Vertex>();
        LinkedList<Edge> vjPath = map.get(vj);
        path.add(vjPath.getFirst().vi);
        for (Edge currentEdge: vjPath) {
            path.add(currentEdge.vj);
        }
        return path;
    }

    /**
     * Finds the shortest path from configuration vi to configuration vj
     * @param vi
     * @param vj
     * @return
     */
    public ArrayList<Vertex> shortestPath(Vertex vi, Vertex vj) {
        // TODO: return a shortest path as an array list
        bfs(vi, vj);
        ArrayList<Vertex> path = retrievePath(vj);
        return path;
    }

    /**
     * Gives the collection of explored vertices
     * @return Ve explored Vertices
     */
    public Set<Vertex> getVertices() {
        return Ve;
    }

    /**
     * Gives the collection of explored edges
     * @return Ee explored edges
     */
    public Set<Edge> getEdges() {
        return Ee;
    }

    public static void main(String[] args) {
        ExploredGraph eg = new ExploredGraph();

        /*

        Testing code
        Vertex v0 = eg.new Vertex("[[4,3,2,1],[],[]]");
        Vertex v1 = eg.new Vertex("[[],[],[4,3,2,1]]");
        eg.shortestPath(v0, v1);
        ArrayList<Vertex> answerPath = eg.retrievePath(v1);
        for (Vertex vertex: answerPath) {
        System.out.println(vertex);
        }
        Vertex v0 = eg.new Vertex("[[4,3,2,1],[],[]]");
        Vertex v1 = eg.new Vertex("[[],[],[4,3,2,1]]");
        eg.dfs(v0, v1);
        ArrayList<Vertex> answerPath = eg.retrievePath(v1);
        for (Vertex vertex: answerPath) {
        System.out.println(vertex);
        }
        System.out.println("VeSize: " + eg.VeSize);
        System.out.println("EeSize: " + eg.EeSize);
        */

    }

    /**
     * Creates a vertex to symbolize a Towers-of-Hanoi configuration
     */
    class Vertex {
        Stack<Integer>[] pegs; // Each vertex will hold a Towers-of-Hanoi state.

        // There will be 3 pegs in the standard version, but more if you do
        // extra credit option A5E1.

        // Constructor that takes a string such as "[[4,3,2,1],[],[]]":
        @SuppressWarnings("unchecked")
        public Vertex(String vString) {
            String[] parts = vString.split("\\],\\[");
            pegs = new Stack[NUMBER_OF_PEGS];
            for (int i = 0; i < NUMBER_OF_PEGS; i++) {
                pegs[i] = new Stack<Integer>();
                try {
                    parts[i] = parts[i].replaceAll("\\[", "");
                    parts[i] = parts[i].replaceAll("\\]", "");
                    ArrayList<String> al = new ArrayList<String>(
                            Arrays.asList(parts[i].split(",")));
                    // System.out.println("ArrayList al is: " + al);
                    Iterator<String> it = al.iterator();
                    while (it.hasNext()) {
                        Object item = it.next();
                        // System.out.println("item is: " + item);
                        Integer diskInteger = new Integer((String) item);
                        pegs[i].push(diskInteger);
                    }
                } catch (Exception e) {
                }
            }
        }

        /**
         * Constructor that takes a Vertex
         * @param vertex
         */
        public Vertex(Vertex vertex) {
            pegs = new Stack[vertex.pegs.length];
            for (int index = 0; index < vertex.pegs.length; index++) {
                pegs[index] = (Stack<Integer>) vertex.pegs[index].clone();
            }
        }

        /**
         * To find a String representation of the vertex
         * @return String representation of Vertex
         */
        public String toString() {
            String ans = "[";
            for (int i = 0; i < NUMBER_OF_PEGS; i++) {
                ans += pegs[i].toString().replace(" ", "");
                if (i < NUMBER_OF_PEGS - 1) {
                    ans += ",";
                }
            }
            ans += "]";
            return ans;
        }

        /**
         * Compares whether this vertex is equal to another vertex
         * @param v other vertex
         * @return boolean of whether the vertex is equal to the other vertex or not
         */
        @Override
        public boolean equals(Object v) {
            if (v instanceof Vertex)
                return hashCode() == v.hashCode();
            else
                return false;
        }

        /**
         * Creates a unique hash code for a
         * @return
         */
        @Override
        public int hashCode() {
            return toString().hashCode();
        }
    }

    /**
     * Edge connecting two vertices, a path between two configurations
     */
    class Edge {
        public Vertex vi;
        public Vertex vj;

        /**
         * Constructor to create an Edge
         * @param vi
         * @param vj
         */
        public Edge(Vertex vi, Vertex vj) {
            this.vi = vi;
            this.vj = vj;
        }

        /**
         * Makes a string of the edge between the two vertices
         * @return string of path
         */
        public String toString() {
            return vi + " -> " + vj;
        }

        /**
         * Checks if this edge is equivalent in value to another edge
         * @param e other edge
         * @return boolean of whether they are equal or not
         */
        @Override
        public boolean equals(Object e) {
            if (e instanceof Edge)
                return hashCode() == e.hashCode();
            else
                return false;
        }

        /**
         * Creates a unique hash code for the edge between vi and vj to avoid collisions
         * @return hash code of the edge
         */
        @Override
        public int hashCode() {
            return vi.hashCode() + vj.hashCode();
        }
    }

    /**
     * Operator that will move a disk from one peg to another
     */
    class Operator {
        private int i, j;

        /**
         * Constructor of an operator
         * @param i initial peg
         * @param j destination peg
         */
        public Operator(int i, int j) {
            this.i = i;
            this.j = j;
        }

        // Additional explanation of what to do here will be given in GoPost or
        // as extra text in the spec.

        /**
         * Checks if a operator can possibly be used in a given configuration based
         * on the top disk on the initial and destination pegs following the
         * Towers of Hanoi rules
         * @return
         */
        @SuppressWarnings("rawtypes")
        Function<Vertex, Boolean> getPrecondition() {
            return new Function<Vertex, Boolean>() {
                @Override
                public Boolean apply(Vertex vertex) {
                    Stack<Integer> currentPeg = vertex.pegs[i];
                    if (!currentPeg.empty()) {
                        Stack<Integer> destinationPeg = vertex.pegs[j];
                        return destinationPeg.empty() || (currentPeg.peek() < destinationPeg.peek());
                    } else {
                        return false;
                    }
                }
            };
        }

        /**
         * Performs the operation of changing disk configuration by performing the move on the given vertex
         * @return the next configuration
         */
        @SuppressWarnings("rawtypes")
        Function<Vertex, Vertex> getTransition() {
            return new Function<Vertex, Vertex>() {
                @Override
                public Vertex apply(Vertex vertex) {
                    vertex = new Vertex(vertex);
                    int diskMoving = vertex.pegs[i].pop();
                    vertex.pegs[j].push(diskMoving);
                    return vertex;
                }
            };
        }

        /**
         * Shows the initial and destination peg that the operator would move the disk
         * would move the disk
         * @return String of disk movement
         */
        public String toString() {
            // TODO: return a string good enough
            // to distinguish different operators
            return i + " -> " + j;
        }
    }

}